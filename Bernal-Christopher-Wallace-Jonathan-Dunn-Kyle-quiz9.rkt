#lang fsm

#|
Grade: A+

Nicely done!
|#

;; Quiz 9 by Christopher Bernal, Kyle Dunn, Jonathan Wallace
;; page 313
;; Exercise 4

#|
Given that L is a context-free language. there exists A G = (make-cfg N Σ R S)
such that L = L(G). A cfg for L* must generate 0 or more words in L.
Each word in L is generated by S. Thus a cfg for L* must generate 0 or more 'S's.


#| Good! |#
V = (grammar-nts G) ∪ {A}
Σ = (grammar-sigma G)
R = (grammar-rules G) ∪ {(S ARROW EMP)(S ARROW SS)}
S = A = (generate-symbol 'S (grammar-nts G))
|#



;; A -> S A
;; A -> EMP
(define (cfg-ks G)
  #| Good! |#
  (let [(A (gen-nt (grammar-nts G)))]  
    (make-cfg (cons A
                    (grammar-nts G))
              (grammar-sigma G)
              (cons (list A ARROW
                          (los->symbol (list (grammar-start G) A)))
                    (cons (list A ARROW EMP)
                          (grammar-rules G)))
              A)))



;; L(G) = {"a")
(define cfg-a
  (cfg-ks
   (make-cfg '(S)
             '(a b)
             `((S ,ARROW a))
             'S)))

#|
   Why are you using check-equal? instead of the shorter
   check-derive? and check-not-derive? ? They can
   significantly shorten your program.
|#
;; tests for cfg-a
(check-equal? (last (grammar-derive cfg-a '(a))) 'a)
(check-equal? (last (grammar-derive cfg-a '(a a))) 'aa)
(check-equal? (grammar-derive cfg-a '(a b)) "(a b) is not in L(G).")
(check-equal? (last (grammar-derive cfg-a '())) EMP)

;; L(G) = {"ab")
(define cfg-ab
  (cfg-ks
   (make-cfg '(S)
             '(a b)
             `((S ,ARROW ab))
             'S)))

;; tests for cfg-ab
(check-equal? (last (grammar-derive cfg-ab '())) EMP)
(check-equal? (grammar-derive cfg-ab '(a)) "(a) is not in L(G).")
(check-equal? (grammar-derive cfg-ab '(a a)) "(a a) is not in L(G).")
(check-equal? (last (grammar-derive cfg-ab '(a b))) 'ab)
(check-equal? (grammar-derive cfg-ab '(a b a)) "(a b a) is not in L(G).")
(check-equal? (last (grammar-derive cfg-ab '(a b a b a b a b))) 'abababab)

;; S -> aSb emp
;; A -> a e
(define cfg_last
  (cfg-ks
   (make-cfg '(S A)
             '(a e b)
             `((S ,ARROW ASb)
               (S ,ARROW ,EMP)
               (A ,ARROW a)
               (A ,ARROW e))
             'S)))

;; tests for cfg_last
(check-equal? (last (grammar-derive cfg_last '())) EMP)
(check-equal? (grammar-derive cfg_last '(a)) "(a) is not in L(G).")
(check-equal? (grammar-derive cfg_last '(b)) "(b) is not in L(G).")
(check-equal? (last (grammar-derive cfg_last '(a b))) 'ab)
(check-equal? (last (grammar-derive cfg_last '(a a b b))) 'aabb)
(check-equal? (last (grammar-derive cfg_last '(a e b b))) 'aebb)
(check-equal? (grammar-derive cfg_last '(a a b)) "(a a b) is not in L(G).")


;; L = a^n b^n
(define a2nb2n
  (make-cfg '(S)
            '(a b)
            `((S -> ,EMP)
              (S -> aSb))
  'S))

;; L = (a^nb^n)*
(define a2nb2n-ks (cfg-ks a2nb2n))
(check-derive? a2nb2n-ks '(a b a b))



;; Exercise 5: proof

#| Bidirectional, 2 lemma proof as we've always done
lemma 1: L* <--> L(G*)
   L = original language
   L* = L but kleene star
   G = original CFG
   G* = original CFG but kleene star = (cfg-ks G)

First: w∈L(G*) -> w∈L*
  Let w ∈ L(G*)
  By the structure of cfg-ks, all derivations start from nonterminal A.
  A only uses the following rules:
   A -> EMP
   A -> S A
  This means that any derivation from A is zero or more subwords of S,
  which is a word in L.
  So, w = w1 w2 w3 ... wk, where wi ∈ L(G) = L
  This means that, w ∈ L* as w is a repeated combination of words in L.
Therefore w∈L(G*) -> w∈L*

Second: L* -> L(G*)
  Let w ∈ L*
  By definition of Kleene star, w = w1 w2 w3 ... wk, where each wi ∈ L = L(G)
  This means that for ever wi, there exists a derivation S ->* wi using G.
  S is the starting symbol of G.
  In G*, A (G* starting symbol) either produces empty or S A.
  This means that when generating w in G*, we produce a sequence of S^k A.
  This is the same as w1 w2 w3 ... wk, so w ∈ L(G*)
Therefore, w∈L -> w∈L(G*)

Lemma 2: w∉L* <--> w∉L(G*)

First: w∉L* -> w∉L(G*)
  Let w ∉ L*
  This means that w can not be comprised of subwords w1 w2 w3 ... wk, where wi is in L = L(G).
  However, in G*, a word is either empty or S A, where S A represents w1 w2 w3 ... wk.
  Since w can not be created in this pattern, w ∉ L(G*)
Therefore, w∉L* -> w∉L(G*)

Second: w∉L(G*) -> w∉L*
  Let w ∉ L(G*)
  This means that w can not be comprised of subwords w1 w2 w3 ... wk, where wi is in L(G) = L.
  However, by definition of kleene star, a word in L* must follow this pattern.
  Since w can not be created in this pattern, w ∉ L*
Therefore, w∉L(G*) -> w∉L*
|#
