#lang fsm

#|
Grade: B-

Good job with the regular expression!

You were a little careless writing the proof. Be careful
about this in the future.

You did not write a word generating function.

|#

;; Formal Lang and Automata
;; Quiz 3 by Christopher Bernal, Kyle Dunn, and Jonathan Wallace

;; Alphabet: {a b}
;; Language: {w | w starts and ends with the same letter}

;; Predicate Function
(define (starts-and-ends-same? w)
  (and (eq? (first w) (last w))
       (andmap (λ (l) (or (eq? l 'a) (eq? l 'b))) w)))
;; Word Generator Function
(define START-EQUALS-END
  (local [;; L(A) = (a) Alphabet = a
          (define A (singleton-regexp "a"))

          ;; L(B) = b Alphabet = (b)
          (define B (singleton-regexp "b"))

          ;; L(AUB) = (a) (b) Alphabet = a b
          (define AUB (union-regexp A B
            #:in-lang '((a) (b))
            #:not-in-lang '((a b) (a b a) (b b b))))           

          ;; L(AUB*) = Words with an arbitrary number of as & bs Alphabet = a b
          (define AUB* (kleenestar-regexp AUB
            #:in-lang '(() (a a a) (b b a b a a) (b a b))))
          
          ;;L(START-END-A) = words with A in front with an arbitrary number of as and bs and an A at the end Alphabet = a b
          (define START-END-A
            (concat-regexp A (concat-regexp AUB* A)            
                           #:sigma '(a b)
                           #:gen-cases 15
                           #:pred (lambda (w) (and (and (eq? (first w) 'a) (eq? (last w) 'a))
                                                   (andmap (λ (l) (or (eq? l 'a) (eq? l 'b))) w)))
                           #:in-lang '((a a a a a) (a b b b a) (a a b a))
                           #:not-in-lang '((b b b b) (a b b b b) (b a))))

          ;;L(START-END-B) = words with B in front with an arbitrary number of as and bs and a B at the end Alphabet = a b
          ;(concat-regexp B (concat-regexp AUB* B))
          (define START-END-B (concat-regexp B (concat-regexp AUB* B)
                           #:sigma '(a b)
                           #:gen-cases 15
                           #:pred (lambda (w) (and (and (eq? (first w) 'b) (eq? (last w) 'b))
                                                   (andmap (λ (l) (or (eq? l 'a) (eq? l 'b))) w)))
                           #:in-lang '((b a a a b) (b b b b b) (b a b b))
                           #:not-in-lang '((a b b b) (a b b b a) (a a))))]
        
    (union-regexp START-END-A START-END-B
    #:sigma '(a b)
    #:gen-cases 20
    #:pred starts-and-ends-same?
    #:in-lang '((a a) (a b a) (a a a) (b b b))
    #:not-in-lang '((a a b) (b a a) (a b) (b a b a a))
    )))

#|
     Function to generate a word in START-EQUALS-END?
|#

#|
Correctness of START-EQUALS-END

A and B only generate, with their respective names, the words a and b, thus they are correct.

AUB nondeterministically generates either a or b, which is {a} U {b}. Thus, AUB is correct.

AUB* nondeterministically generates a word of arbitrary length containing only as and bs, which generates ({a} U {b})*. Thus, it is correct.

START-END-A concatenates the word a with a word generated by AUB* and concatenates an A
to the end of the word generated by AUB*.
This generates a word {a} U ({({a} U {b})*} U {a}).
  #|
     It does not! You have too many unions. The first and last U should not be there.
     You are concatenating.
  |#
Thus, it is correct.

START-END-B concatenates the word b with a word generated by AUB* and concatenates the word b to the end of the word generated by AUB*.
This generates a word {b} U ({({a} U {b})*} U {b}).
  #|
     It does not! You have too many unions. The first and last U should not be there.
     You are concatenating.
  |#
Thus, it is correct.

START-EQUALS-END either generates a word generated by START-END-A or START-END-B.
It generates a word with the same letter in the beginning and at the end.
Thus, it is correct. 

|#
